(()=>{var n={792:function(n){n.exports=function(){"use strict";var n=function(){var t=0,e=document.createElement("div");function o(n){return e.appendChild(n.dom),n}function i(n){for(var o=0;o<e.children.length;o++)e.children[o].style.display=o===n?"block":"none";t=n}e.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",e.addEventListener("click",(function(n){n.preventDefault(),i(++t%e.children.length)}),!1);var r=(performance||Date).now(),a=r,s=0,c=o(new n.Panel("FPS","#0ff","#002")),f=o(new n.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var l=o(new n.Panel("MB","#f08","#201"));return i(0),{REVISION:16,dom:e,addPanel:o,showPanel:i,begin:function(){r=(performance||Date).now()},end:function(){s++;var n=(performance||Date).now();if(f.update(n-r,200),a+1e3<=n&&(c.update(1e3*s/(n-a),100),a=n,s=0,l)){var t=performance.memory;l.update(t.usedJSHeapSize/1048576,t.jsHeapSizeLimit/1048576)}return n},update:function(){r=this.end()},domElement:e,setMode:i}};return n.Panel=function(n,t,e){var o=1/0,i=0,r=Math.round,a=r(window.devicePixelRatio||1),s=80*a,c=48*a,f=3*a,l=2*a,d=3*a,p=15*a,u=74*a,v=30*a,m=document.createElement("canvas");m.width=s,m.height=c,m.style.cssText="width:80px;height:48px";var h=m.getContext("2d");return h.font="bold "+9*a+"px Helvetica,Arial,sans-serif",h.textBaseline="top",h.fillStyle=e,h.fillRect(0,0,s,c),h.fillStyle=t,h.fillText(n,f,l),h.fillRect(d,p,u,v),h.fillStyle=e,h.globalAlpha=.9,h.fillRect(d,p,u,v),{dom:m,update:function(c,g){o=Math.min(o,c),i=Math.max(i,c),h.fillStyle=e,h.globalAlpha=1,h.fillRect(0,0,s,p),h.fillStyle=t,h.fillText(r(c)+" "+n+" ("+r(o)+"-"+r(i)+")",f,l),h.drawImage(m,d+a,p,u-a,v,d,p,u-a,v),h.fillRect(d+u-a,p,a,v),h.fillStyle=e,h.globalAlpha=.9,h.fillRect(d+u-a,p,a,r((1-c/g)*v))}}},n}()},779:n=>{n.exports="#version 300 es\nprecision highp float;\n\nuniform vec3 u_Eye, u_Ref, u_Up;\nuniform vec2 u_Dimensions;\nuniform float u_Time;\n\nin vec2 fs_Pos;\nout vec4 out_Col;\n\nvoid main() {\n  out_Col = vec4(0.5 * (fs_Pos + vec2(1.0)), 0.5 * (sin(u_Time * 3.14159 * 0.01) + 1.0), 1.0);\n}\n"},538:n=>{n.exports="#version 300 es\nprecision highp float;\n\n// The vertex shader used to render the background of the scene\n\nin vec4 vs_Pos;\nout vec2 fs_Pos;\n\nvoid main() {\n  fs_Pos = vs_Pos.xy;\n  gl_Position = vs_Pos;\n}\n"},348:n=>{n.exports='#version 300 es\nprecision highp float;\n\nuniform vec3 u_Eye, u_Ref, u_Up;\nuniform vec2 u_Dimensions;\nuniform float u_Time;\nuniform vec4 u_Color;\n\nin vec2 fs_Pos;\nout vec4 out_Col;\n\n#define EPSILON          0.01\n#define INFINITY         1000000.0\n#define MAX_STEPS        128\n#define MAX_DEPTH        100.0\n#define MAX_RAY_LENGTH   1000.0\n\n#define KEY_LIGHT        vec3(0.9, 0.8, 0.4) * 1.8\n#define FILL_LIGHT       vec3(0.5, 0.85, 0.95) * 0.2\n#define AMBIENT_LIGHT    vec3(0.9, 0.8, 0.3) * 0.2\n\n#define PI               3.1415926535897932384626433832795\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Intersection\n{\n    vec3 point;\n    vec3 normal;\n    float t;\n};\n\nstruct Material\n{\n    int type;\n    vec3 color;\n};\n\nstruct DirectionalLight\n{\n    vec3 direction;\n    vec3 color;\n};\n\nmat3 rotateY3D(float angle)\n{\n    return mat3(cos(angle), 0, -sin(angle),\n                0, 1, 0, \n                sin(angle), 0, cos(angle));\n}\n\nmat3 identity()\n{\n    return mat3(1, 0, 0,\n                0, 1, 0, \n                0, 0, 1);\n}\n\nfloat bias(float b, float t)\n{\n    return pow(t, log(b) / log(0.5f));\n}\n\n// Noise and interpolation functions based on CIS 560 and CIS 566 Slides - "Noise Functions"\nfloat noise2Df(vec2 p) {\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\nvec2 noise2Dv( vec2 p ) {\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5,183.3)))) * 43758.5453);\n}\n\nfloat noise3Df(vec3 p) \n{\n    return fract(sin((dot(p, vec3(127.1, 311.7, 191.999)))) * 43758.5453);\n}\n\nvec3 noise3Dv(vec3 p) {\n    return fract(sin(vec3(dot(p, vec3(127.1, 311.7, 191.999)),\n                 dot(p, vec3(269.5,183.3,483.1)),\n                 dot(p, vec3(564.5,96.3,223.9))))\n                 * 43758.5453);\n}\n\nfloat cosineInterpolate(float a, float b, float t)\n{\n    float cos_t = (1.f - cos(t * PI)) * 0.5f;\n    return mix(a, b, cos_t);\n}\n\nfloat interpolateNoise2D(float x, float y) \n{\n    // Get integer and fractional components of current position\n    int intX = int(floor(x));\n    float fractX = fract(x);\n    int intY = int(floor(y));\n    float fractY = fract(y);\n\n    // Get noise value at each of the 4 vertices\n    float v1 = noise2Df(vec2(intX, intY));\n    float v2 = noise2Df(vec2(intX + 1, intY));\n    float v3 = noise2Df(vec2(intX, intY + 1));\n    float v4 = noise2Df(vec2(intX + 1, intY + 1));\n\n    // Interpolate in the X, Y directions\n    float i1 = cosineInterpolate(v1, v2, fractX);\n    float i2 = cosineInterpolate(v3, v4, fractX);\n    return cosineInterpolate(i1, i2, fractY);\n}\n\nfloat fbm2D(vec2 p) \n{\n    float total = 0.f;\n    float persistence = 0.5f;\n    int octaves = 4;\n\n    for(int i = 1; i <= octaves; i++)\n    {\n        float freq = pow(2.f, float(i));\n        float amp = pow(persistence, float(i));\n\n        float perlin = interpolateNoise2D(p.x * freq, p.y * freq);\n        total += amp * (0.5 * (perlin + 1.0));\n    }\n    return total;\n}\n\nfloat worley3D(vec3 p) {\n    // Tile space\n    p *= 2.0;\n    vec3 pInt = floor(p);\n    vec3 pFract = fract(p);\n    float minDist = 1.0; // Minimum distance\n\n    // Iterate through neighboring cells to find closest point\n    for(int z = -1; z <= 1; ++z) {\n        for(int y = -1; y <= 1; ++y) {\n            for(int x = -1; x <= 1; ++x) {\n                vec3 neighbor = vec3(float(x), float(y), float(z)); \n                vec3 point = noise3Dv(pInt + neighbor); // Random point in neighboring cell\n                \n                // Distance between fragment and neighbor point\n                vec3 diff = neighbor + point - pFract; \n                float dist = length(diff); \n                minDist = min(minDist, dist);\n            }\n        }\n    }\n\n    // Set pixel brightness to distance between pixel and closest point\n    return minDist;\n}\n\nfloat interpolateNoise3D(float x, float y, float z)\n{\n    // Get integer and fractional components of current position\n    int intX = int(floor(x));\n    float fractX = fract(x);\n    int intY = int(floor(y));\n    float fractY = fract(y);\n    int intZ = int(floor(z));\n    float fractZ = fract(z);\n\n    // Get noise value at each of the 8 vertices\n    float v1 = noise3Df(vec3(intX, intY, intZ));\n    float v2 = noise3Df(vec3(intX + 1, intY, intZ));\n    float v3 = noise3Df(vec3(intX, intY + 1, intZ));\n    float v4 = noise3Df(vec3(intX + 1, intY + 1, intZ));\n    float v5 = noise3Df(vec3(intX, intY, intZ + 1));\n    float v6 = noise3Df(vec3(intX + 1, intY, intZ + 1));\n    float v7 = noise3Df(vec3(intX, intY + 1, intZ + 1));\n    float v8 = noise3Df(vec3(intX + 1, intY + 1, intZ + 1));\n\n    // Interpolate in the X, Y, Z directions\n    float i1 = cosineInterpolate(v1, v2, fractX);\n    float i2 = cosineInterpolate(v3, v4, fractX);\n    float mix1 = cosineInterpolate(i1, i2, fractY);\n    float i3 = cosineInterpolate(v5, v6, fractX);\n    float i4 = cosineInterpolate(v7, v8, fractX);\n    float mix2 = cosineInterpolate(i3, i4, fractY);\n    return cosineInterpolate(mix1, mix2, fractZ);\n}\n\nfloat fbm3D(vec3 p)\n{\n    float total = 0.f;\n    float persistence = 0.5f;\n    int octaves = 3;\n\n    for (int i = 1; i < octaves; ++i)\n    {\n        float freq = pow(2.f, float(i));\n        float amp = pow(persistence, float(i));\n\n        total += amp * interpolateNoise3D(p.x * freq, p.y * freq, p.z * freq);\n    }\n\n    return total;\n}\n\nfloat worley2D(vec2 p, int animate) {\n    // Tile space\n    p *= 2.0;\n    vec2 pInt = floor(p);\n    vec2 pFract = fract(p);\n    float minDist = 1.0; // Minimum distance\n\n    // Iterate through neighboring cells to find closest point\n    for(int z = -1; z <= 1; ++z) {\n        for(int x = -1; x <= 1; ++x) {\n            vec2 neighbor = vec2(float(x), float(z)); \n            vec2 point = noise2Dv(pInt + neighbor); // Random point in neighboring cell\n            if (animate == 1) point = 0.5 + 0.5 * sin(0.5 * u_Time * 0.1 + 6.2831 * point);\n            \n            // Distance between fragment and neighbor point\n            vec2 diff = neighbor + point - pFract; \n            float dist = length(diff); \n            minDist = min(minDist, dist);\n        }\n    }\n    // Set pixel brightness to distance between pixel and closest point\n    return minDist;\n}\n\nbool getRayLength(vec3 p, vec3 rayOrigin)\n{\n    return length(p - rayOrigin) > MAX_RAY_LENGTH;\n}\n\n// SDF functions\nfloat smoothUnion(float d1, float d2, float k) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat sphereSDF(vec3 rayPos, vec3 objectPos, float radius)\n{\n    return length(rayPos - objectPos) - radius;\n}\n\nfloat capsuleSDF(vec3 rayPos, vec3 a, vec3 b, float r)\n{\n    vec3 pa = rayPos - a, ba = b - a;\n    float h = clamp(dot(pa, ba)/ dot(ba, ba), 0.0, 1.0);\n    return length( pa - ba * h ) - r;\n}\n\nfloat roundedBoxSDF(vec3 rayPos, vec3 objectPos, mat3 transform, vec3 b, float r)\n{\n    vec3 p = (rayPos - objectPos) * transform; //* rotateY3D(-0.528);\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - r;\n}\n\nfloat planeSDF(vec3 rayPos, float h)\n{\n    return rayPos.y - h; \n}\n\nfloat trainSDF(vec3 rayPos, out Material mat)\n{\n    mat3 id = identity();\n\n    // Front car\n    vec3 p = vec3(-250.0, -40.0, -63.5 + 0.8 * mod(u_Time, 300.0));\n    float carFront = roundedBoxSDF(rayPos, p, id, vec3(3.0, 1.0, 10.0), 1.0);\n\n    // Back car\n    vec3 r = vec3(-250.0, -40.0, -41.5 + 0.8 * mod(u_Time, 300.0));\n    float carBack = roundedBoxSDF(rayPos, r, id, vec3(3.0, 1.0, 10.0), 1.0); \n\n    float dMin = min(carFront, carBack);\n    mat.type = 2;\n    mat.color = vec3(0.9, 0.1, 0.1);\n    return dMin;\n}\n\nfloat groundSDF(vec3 rayPos, out Material mat)\n{\n    // Water\n    float wOffset = 1.0 - worley2D(0.05 * rayPos.xz, 1);\n    wOffset += smoothstep(-1.0, 1.0, 29.8 * fract(wOffset));\n    float water = planeSDF(rayPos - wOffset, -43.0);\n    float dMin = water;\n\n    // Cliff\n    float cliffBoundingBox = roundedBoxSDF(rayPos, vec3(-45.0, -25.0, -80.0), rotateY3D(-0.508), vec3(50.5, 50.0, 80.0), 0.0);\n    float cliff = INFINITY;\n    float xOffset = 0.0;\n    float zOffset = 0.0;\n    if (cliffBoundingBox <= EPSILON)\n    {\n        xOffset = fbm2D(0.3 * sin(rayPos.xz + 1.0f));\n        zOffset = cos(0.15 * rayPos.y - 1.0f);\n        cliff = roundedBoxSDF(rayPos, vec3(-45.0 + xOffset, -25.0, -80.0 + zOffset), rotateY3D(-0.508), vec3(20.5, 15.5, 55.5), 5.5);\n        dMin = min(water, cliff);\n    }\n    //dMin = min(water, cliffBoundingBox);\n\n    // Mountains\n    float mountainBoundingBox = roundedBoxSDF(rayPos, vec3(-600.0, 0.0, -300.0), rotateY3D(-0.408), vec3(110.5, 50.0, 575.0), 0.0);\n    float mountains = INFINITY;\n    float mNoise = 0.0;\n    if (mountainBoundingBox <= EPSILON)\n    {\n        mNoise = fbm2D(0.01 * rayPos.xz);\n        float yOffset = 200.f * mNoise;\n        mountains = roundedBoxSDF(rayPos, vec3(-600.0, -253.0 + yOffset, -200.0 - yOffset), rotateY3D(-0.408), vec3(20.5, 0.5, 500.5), 120.5);\n        dMin = min(dMin, mountains);\n    }\n\n    // Vegetation\n    float wNoise = 2.f * worley2D(0.15 * rayPos.xz, 0);\n    //wNoise *= fbm2D(2.5f * rayPos.xz + 5.0);\n    float yOffset = smoothstep(0.3, 0.9, 1.0 - wNoise);\n    float grass = roundedBoxSDF(rayPos, vec3(-45.0 + xOffset, -10.0 + yOffset, -80.0 + zOffset), rotateY3D(-0.508), vec3(19.0, 2.0, 55.5), 5.5);\n    dMin = min(dMin, grass);\n\n    // Assign color\n    if (dMin == water)\n    {\n        mat.type = 3;\n        mat.color = mix(vec3(0.1, 0.4, 0.9), vec3(0.2, 0.5, 1.0), wOffset);\n    }\n    else if (dMin == cliff) \n    {\n        mat.type = 4;\n        mat.color = vec3(0.8, 0.7, 0.6);\n    }\n    else if (dMin == mountains) \n    {\n        mat.type = 5;\n        mat.color = mix(vec3(0.7, 0.3, 0.2), vec3(10.0, 10.0, 10.0), bias(mNoise, 0.01));\n    }\n    else \n    {\n        mat.type = 6;\n        mat.color = mix(vec3(0.0, 0.9, 0.0), vec3(0.2, 1.0, 0.3), wNoise);\n    }\n    \n    return dMin;\n}\n\nfloat bridgeSDF(vec3 rayPos, out Material mat)\n{\n    // Add sine distortion to origin rayPos to make bridge curve up\n    vec3 p = rayPos;\n    p.y += sin(0.1f * rayPos.z - 1.5f) + 1.8f; \n    mat3 id = identity();\n\n    // Ground planks\n    vec3 q = vec3(p.x, p.y, mod(p.z, 0.4));\n    float bridgeFloor = roundedBoxSDF(q, vec3(3.0, 0.0, 0.0), id, vec3(2.0, 0.05, 0.35), 0.1);\n    float dMin = bridgeFloor;\n\n    // Vertical planks\n    q = vec3(p.x, p.y, mod(p.z, 3.0));\n    float bridgeVert1 = roundedBoxSDF(q, vec3(1.1, 1.0, 0.0), id, vec3(0.1, 1.0, 0.2), 0.02);\n    dMin = min(dMin, bridgeVert1);\n\n    q = vec3(p.x, p.y, mod(p.z + 0.5, 3.0));\n    float bridgeVert2 = roundedBoxSDF(q, vec3(1.1, 0.5, 2.0), id, vec3(0.08, 0.5, 0.08), 0.02);\n    dMin = min(dMin, bridgeVert2);\n\n    // Horizontal planks\n    q = vec3(p.x, p.y, mod(p.z + 5.0, 3.5)) - vec3(0.0, -0.8, 0.0);\n    float lower = roundedBoxSDF(q, vec3(1.1, 1.0, 0.0), id, vec3(0.15, 0.09, 3.5), 0.02);\n    dMin = min(dMin, lower);\n\n    q = vec3(p.x, p.y, mod(p.z + 5.0, 3.5));\n    float lower2 = roundedBoxSDF(q, vec3(1.1, 1.1, 0.0), id, vec3(0.08, 0.1, 3.5), 0.02);\n    dMin = min(dMin, lower2);\n    \n    q = vec3(p.x, p.y, mod(p.z + 5.0, 3.5)) - vec3(0.0, 0.8, 0.0);\n    float lower3 = roundedBoxSDF(q, vec3(1.1, 1.2, 0.0), id, vec3(0.2, 0.05, 3.5), 0.02);\n    dMin = min(dMin, lower3);\n\n    // Assign color depending on part of bridge\n    if (dMin == bridgeFloor)\n    {\n        mat.type = 0;\n        mat.color = vec3(0.5);\n    }\n    else {\n        mat.type = 1;\n        mat.color = vec3(0.9, 0.1, 0.1);\n    }\n\n    return dMin;\n}\n\nfloat sceneSDF(vec3 rayPos, out Material mat)\n{\n    Material groundMat;\n    float ground = groundSDF(rayPos, groundMat);\n    float dMin = ground;\n\n    Material bridgeMat;\n    float bridge = bridgeSDF(rayPos, bridgeMat);\n    dMin = min(dMin, bridge);\n\n    Material trainMat;\n    float train = trainSDF(rayPos, trainMat);\n    dMin = min(dMin, train);\n\n    // Assign color\n    if (dMin == ground) {\n        mat.type = groundMat.type;\n        mat.color = groundMat.color;\n    }\n    else if (dMin == bridge) {\n        mat.type = bridgeMat.type;\n        mat.color = bridgeMat.color;\n    }\n    else {\n        mat.type = trainMat.type;\n        mat.color = trainMat.color;\n    }\n\n    return dMin;\n}\n\n// Terrain raymarching height function\nfloat f(float x, float z)\n{\n    return 3.f * fbm2D(0.5 * vec2(x, z));\n}\n\nvec3 getBackgroundColor(vec2 uv)\n{\n    // Clouds\n    vec3 color = vec3(0.5, 0.85, 0.95);\n    float noise = smoothstep(0.61, 0.7, fbm2D(uv + vec2(0.005 * u_Time, 0.0)));\n    color = mix(vec3(1.0), color, noise);\n\n    return color;\n}\n\n// Function to get ray from uv coord (from Mushroom Lab)\nRay getRay(vec2 uv)\n{\n    Ray ray;\n\n    float aspect = u_Dimensions.x / u_Dimensions.y;\n    float len = tan(3.14159 * 0.125) * distance(u_Eye, u_Ref);\n    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), u_Ref - u_Eye));\n    vec3 V = normalize(cross(H, u_Eye - u_Ref));\n    V *= len;\n    H *= len * aspect;\n    vec3 p = u_Ref + uv.x * H + uv.y * V;\n    vec3 dir = normalize(p - u_Eye);\n\n    ray.origin = u_Eye;\n    ray.direction = dir;\n    return ray;\n}\n\n// Estimate the normal at an intersection point\nvec3 estimateNormal(vec3 p)\n{\n    Material mat;\n    float gx = sceneSDF(vec3(p.x + EPSILON, p.y, p.z), mat) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z), mat);\n    float gy = sceneSDF(vec3(p.x, p.y + EPSILON, p.z), mat) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z), mat);\n    float gz = sceneSDF(vec3(p.x, p.y, p.z + EPSILON), mat) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON), mat);\n    return normalize(vec3(gx, gy, gz));\n}\n\n// Add patchy green areas to the cliff and mountains\nvec3 editColor(Material mat, vec3 normal)\n{\n    if (mat.type == 4 || mat.type == 5)\n    {\n        return smoothstep(0.3, 0.7, mix(mat.color, vec3(0.0, 0.9, 0.0), normal.y));\n    }\n    return mat.color;\n}\n\n// Soft shadows - from https://iquilezles.org/articles/rmshadows/\nfloat calcShadows(vec3 rayOrigin, vec3 rayDirection, float k)\n{\n    Material mat;\n    float res = 1.0;\n    for (float t = 2.0; t < float(MAX_STEPS); ++t)\n    {\n        vec3 p = rayOrigin + t * rayDirection;\n        if (getRayLength(p, rayOrigin)) break; \n        float s = sceneSDF(p, mat);\n        if (s < EPSILON)\n        {\n            return 0.0;\n        }\n        if (t > MAX_DEPTH)\n        {\n            break;\n        }\n        res = min(res, k * s / t);\n        t += s;\n    }\n    return res;\n}\n\nIntersection raymarch(vec2 uv, Ray ray, out Material mat)\n{\n    Intersection intersection;\n\n    vec3 p = ray.origin;\n    for (int i = 0; i < MAX_STEPS; ++i)\n    {     \n        // If ray is too long, skip (avoid testing empty space)\n        if (getRayLength(p, ray.origin)) break; \n\n        float dist = sceneSDF(p, mat);\n        if (dist < EPSILON)\n        {\n            intersection.point = p;\n            intersection.normal = estimateNormal(p);\n            intersection.t = length(p - ray.origin);\n            mat.color = editColor(mat, intersection.normal);\n            return intersection;\n        }\n        if (intersection.t > MAX_DEPTH)\n        {\n            break;\n        }\n        p = p + dist * ray.direction;\n    }\n    intersection.t = -1.0;\n    return intersection;\n}\n\nIntersection raymarchTerrain(vec2 uv, Ray ray)\n{\n    Intersection intersection;\n\n    for (float t = 0.f; t < 5.f; t += 0.01f)\n    {     \n        vec3 p = ray.origin + t * ray.direction;  \n        float height = f(p.x, p.z);\n        if (p.y < height)\n        {\n            intersection.normal = estimateNormal(p);\n            //intersection.t = length(p - ray.origin);\n            intersection.t = t;\n            return intersection;\n        }       \n    }\n    intersection.t = -1.0;\n    return intersection;\n}\n\nvoid main() {\n\n    // Material base color (before shading)\n    vec3 albedo = vec3(0.5);\n    vec3 color = vec3(0.0);\n\n    // Lights\n    DirectionalLight lights[3];\n    lights[0] = DirectionalLight(normalize(vec3(-10.0, 20.0, -20.0)), KEY_LIGHT);\n    lights[1] = DirectionalLight(normalize(vec3(0.0, 1.0, 0.0)), FILL_LIGHT);\n    lights[2] = DirectionalLight(normalize(-vec3(-10.0, 0.0, -20.0)), AMBIENT_LIGHT);\n\n    // Raymarch scene\n    vec2 ndc = gl_FragCoord.xy / u_Dimensions.xy;\n    ndc = ndc * 2.0 - 1.0;\n    Ray ray = getRay(ndc);\n\n    Material mat;\n    Intersection isect = raymarch(ndc, ray, mat);\n    //Intersection isect = raymarchTerrain(ndc, ray);\n\n    // Lighting calculations\n    if (isect.t > 0.0) \n    {\n        for (int i = 0; i < 3; i++)\n        {\n            float shadow = calcShadows(isect.point, lights[i].direction, 3.0);\n            //float shadow = 1.0;\n            float cosTheta = max(0.0, dot(isect.normal, lights[i].direction));\n            color += mat.color * lights[i].color * cosTheta * clamp(0.0, 0.5, shadow);\n        }    \n    }\n    else \n    {\n        color = getBackgroundColor(ndc);\n    }\n\n    // Distance fog\n    vec3 fog_dist = exp(-0.001 * isect.t * vec3(1.0, 1.5, 1.7));\n    vec3 fog_t = smoothstep(0.0, 0.8, fog_dist);\n    color = mix(vec3(0.5, 0.85, 0.85), color, fog_t);\n\n    // Final color correction\n    color = pow(color, vec3(1.0, 0.9, 1.0)) + vec3(0.0, 0.0, 1.0) * 0.01;\n    color = pow(color, vec3(1.0 / 2.2));\n\n    // Compute final shaded color\n    out_Col = vec4(color.rgb, 1.0);\n}\n'},257:n=>{n.exports="#version 300 es\nprecision highp float;\n\nin vec4 vs_Pos;\nout vec2 fs_Pos;\n\nvoid main() {\n  fs_Pos = vs_Pos.xy;\n  gl_Position = vs_Pos;\n}\n"}},t={};function e(o){var i=t[o];if(void 0!==i)return i.exports;var r=t[o]={exports:{}};return n[o].call(r.exports,r,r.exports,e),r.exports}(()=>{"use strict";var n,t,o=1e-6,i="undefined"!=typeof Float32Array?Float32Array:Array;function r(){var n=new i(3);return i!=Float32Array&&(n[0]=0,n[1]=0,n[2]=0),n}function a(n,t,e){var o=new i(3);return o[0]=n,o[1]=t,o[2]=e,o}function s(t){n=t}Math.random,Math.PI,Math.hypot||(Math.hypot=function(){for(var n=0,t=arguments.length;t--;)n+=arguments[t]*arguments[t];return Math.sqrt(n)}),r(),t=new i(4),i!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0,t[3]=0);const c=class{constructor(n){this.canvas=n}setClearColor(t,e,o,i){n.clearColor(t,e,o,i)}setSize(n,t){this.canvas.width=n,this.canvas.height=t}clear(){n.clear(n.COLOR_BUFFER_BIT|n.DEPTH_BUFFER_BIT)}render(n,t,e,o){t.setEyeRefUp(a(8,2,10),a(-13,0,0),a(0,1,0)),t.setTime(o);for(let n of e)t.draw(n)}};function f(){var n=new i(16);return i!=Float32Array&&(n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[11]=0,n[12]=0,n[13]=0,n[14]=0),n[0]=1,n[5]=1,n[10]=1,n[15]=1,n}function l(n,t,e,i){var r,a,s,c,f,l,d,p,u,v,m=t[0],h=t[1],g=t[2],y=i[0],x=i[1],w=i[2],D=e[0],b=e[1],M=e[2];return Math.abs(m-D)<o&&Math.abs(h-b)<o&&Math.abs(g-M)<o?function(n){return n[0]=1,n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=1,n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[10]=1,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,n}(n):(d=m-D,p=h-b,u=g-M,r=x*(u*=v=1/Math.hypot(d,p,u))-w*(p*=v),a=w*(d*=v)-y*u,s=y*p-x*d,(v=Math.hypot(r,a,s))?(r*=v=1/v,a*=v,s*=v):(r=0,a=0,s=0),c=p*s-u*a,f=u*r-d*s,l=d*a-p*r,(v=Math.hypot(c,f,l))?(c*=v=1/v,f*=v,l*=v):(c=0,f=0,l=0),n[0]=r,n[1]=c,n[2]=d,n[3]=0,n[4]=a,n[5]=f,n[6]=p,n[7]=0,n[8]=s,n[9]=l,n[10]=u,n[11]=0,n[12]=-(r*m+a*h+s*g),n[13]=-(c*m+f*h+l*g),n[14]=-(d*m+p*h+u*g),n[15]=1,n)}var d=null;class p{constructor(t,e){if(this.shader=n.createShader(t),n.shaderSource(this.shader,e),n.compileShader(this.shader),!n.getShaderParameter(this.shader,n.COMPILE_STATUS))throw n.getShaderInfoLog(this.shader)}}const u=class{constructor(t){this.prog=n.createProgram();for(let e of t)n.attachShader(this.prog,e.shader);if(n.linkProgram(this.prog),!n.getProgramParameter(this.prog,n.LINK_STATUS))throw n.getProgramInfoLog(this.prog);this.attrPos=n.getAttribLocation(this.prog,"vs_Pos"),this.unifEye=n.getUniformLocation(this.prog,"u_Eye"),this.unifRef=n.getUniformLocation(this.prog,"u_Ref"),this.unifUp=n.getUniformLocation(this.prog,"u_Up"),this.unifDimensions=n.getUniformLocation(this.prog,"u_Dimensions"),this.unifTime=n.getUniformLocation(this.prog,"u_Time")}use(){d!==this.prog&&(n.useProgram(this.prog),d=this.prog)}setEyeRefUp(t,e,o){this.use(),-1!==this.unifEye&&n.uniform3f(this.unifEye,t[0],t[1],t[2]),-1!==this.unifRef&&n.uniform3f(this.unifRef,e[0],e[1],e[2]),-1!==this.unifUp&&n.uniform3f(this.unifUp,o[0],o[1],o[2])}setDimensions(t,e){this.use(),-1!==this.unifDimensions&&n.uniform2f(this.unifDimensions,t,e)}setTime(t){this.use(),-1!==this.unifTime&&n.uniform1f(this.unifTime,t)}draw(t){this.use(),-1!=this.attrPos&&t.bindPos()&&(n.enableVertexAttribArray(this.attrPos),n.vertexAttribPointer(this.attrPos,4,n.FLOAT,!1,0,0)),t.bindIdx(),n.drawElements(t.drawMode(),t.elemCount(),n.UNSIGNED_INT,0),-1!=this.attrPos&&n.disableVertexAttribArray(this.attrPos)}},v=e(792);let m,h=0;function g(){m=new class extends class{constructor(){this.count=0,this.idxBound=!1,this.posBound=!1}destory(){n.deleteBuffer(this.bufIdx),n.deleteBuffer(this.bufPos)}generateIdx(){this.idxBound=!0,this.bufIdx=n.createBuffer()}generatePos(){this.posBound=!0,this.bufPos=n.createBuffer()}bindIdx(){return this.idxBound&&n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,this.bufIdx),this.idxBound}bindPos(){return this.posBound&&n.bindBuffer(n.ARRAY_BUFFER,this.bufPos),this.posBound}elemCount(){return this.count}drawMode(){return n.TRIANGLES}}{constructor(n){var t,e,o,r;super(),this.center=(t=n[0],e=n[1],o=n[2],(r=new i(4))[0]=t,r[1]=e,r[2]=o,r[3]=1,r)}create(){this.indices=new Uint32Array([0,1,2,0,2,3]),this.positions=new Float32Array([-1,-1,.999,1,1,-1,.999,1,1,1,.999,1,-1,1,.999,1]),this.generateIdx(),this.generatePos(),this.count=this.indices.length,n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,this.bufIdx),n.bufferData(n.ELEMENT_ARRAY_BUFFER,this.indices,n.STATIC_DRAW),n.bindBuffer(n.ARRAY_BUFFER,this.bufPos),n.bufferData(n.ARRAY_BUFFER,this.positions,n.STATIC_DRAW),console.log("Created square")}}(a(0,0,0)),m.create()}!function(){window.addEventListener("keypress",(function(n){n.key}),!1),window.addEventListener("keyup",(function(n){n.key}),!1);const n=v();n.setMode(0),n.domElement.style.position="absolute",n.domElement.style.left="0px",n.domElement.style.top="0px",document.body.appendChild(n.domElement);const t=document.getElementById("canvas"),o=t.getContext("webgl2");o||alert("WebGL 2 not supported!"),s(o),g();const i=new class{constructor(n,t,e){this.projectionMatrix=f(),this.viewMatrix=f(),this.fovy=45,this.aspectRatio=1,this.near=.1,this.far=1e3,this.position=r(),this.direction=r(),this.target=r(),this.up=r(),l(this.viewMatrix,a(8,2,10),a(-13,0,0),a(0,1,0))}setAspectRatio(n){this.aspectRatio=n}updateProjectionMatrix(){var n,t,e,o,i,r,a;n=this.projectionMatrix,t=this.fovy,e=this.aspectRatio,o=this.near,i=this.far,a=1/Math.tan(t/2),n[0]=a/e,n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=a,n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[11]=-1,n[12]=0,n[13]=0,n[15]=0,null!=i&&i!==1/0?(r=1/(o-i),n[10]=(i+o)*r,n[14]=2*i*o*r):(n[10]=-1,n[14]=-2*o)}update(){l(this.viewMatrix,a(8,2,10),a(-13,0,0),a(0,1,0))}}(a(8,2,10),a(-13,0,0),a(0,1,0)),d=new c(t);d.setClearColor(164/255,233/255,1,1),o.enable(o.DEPTH_TEST);const y=new u([new p(o.VERTEX_SHADER,e(538)),new p(o.FRAGMENT_SHADER,e(779))]),x=new u([new p(o.VERTEX_SHADER,e(257)),new p(o.FRAGMENT_SHADER,e(348))]);window.addEventListener("resize",(function(){d.setSize(window.innerWidth,window.innerHeight),i.setAspectRatio(window.innerWidth/window.innerHeight),i.updateProjectionMatrix(),y.setDimensions(window.innerWidth,window.innerHeight),x.setDimensions(window.innerWidth,window.innerHeight)}),!1),d.setSize(window.innerWidth,window.innerHeight),i.setAspectRatio(window.innerWidth/window.innerHeight),i.updateProjectionMatrix(),y.setDimensions(window.innerWidth,window.innerHeight),x.setDimensions(window.innerWidth,window.innerHeight),function t(){i.update(),n.begin(),o.viewport(0,0,window.innerWidth,window.innerHeight),d.clear(),d.render(i,x,[m],h),h++,n.end(),requestAnimationFrame(t)}()}()})()})();
//# sourceMappingURL=bundle.js.map